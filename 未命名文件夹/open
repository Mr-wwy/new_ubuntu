 open函数用来在进程中打开文件，如果成功则返回一个文件描述符fd。
=======================================================
函数原型： int open(const char * pathname, int flags);
    int open(const char * pathname, int flags, mode_t mode);
函数参数：

    pathname：打开文件的路径名
    flags：用来控制打开文件的模式
    mode：用来设置创建文件的权限（rwx）。当flags中带有O_CREAT时才有效。

返回值：

    调用成功时返回一个文件描述符fd
    调用失败时返回-1，并修改errno

=======================================================
flags参数详解：

    O_RDONLY：只读模式
    O_WRONLY：只写模式
    O_RDWR：可读可写模式

上面三种模式在flags参数中不能同时出现但必须有一种出现，下面的参数是可选的。

    O_APPEND：以后每次写文件时都会先将当前文件偏移量设置到文件末尾，但是读文件时时不影响的
    O_CREAT：如果文件不存在则创建
    O_EXCL：要打开的文件如果存在则出错，必须要和O_CREAT参数一起使用
    O_TRUNC：打开文件的同时将文件中的内容清除
    O_NOCTTY：如果打开的文件是终端设备，则不将此设备设置为进程的控制终端
    O_NONBLOCK：如果打开的文件是一个管道、一个块设备文件或一个字符设备文件，则后续的I/O操作均设置为非阻塞方式
    O_SYNC：使每次write都等到物理I/O操作完成

========================================================
    open函数返回的文件描述符fd一定是未使用的最小的文件描述符。利用这个特性，可以改变0，1，2这三个文件描述符所指向的文件，由于进程默认会打开0，1，2这三个文件描述符，而且指向了键盘和显示器的设备文件。如果在open之前先进行close(1)，然后再调用open函数就会返回最小的未使用的fd，也就是1。
 =======================================================
    如果文件不存在，而且又使用了O_CREAT标志，也就是会创建文件，创建文件时会给文件一定的权限，但是这个权限并不会限制该进程后面对该文件的操作。举个例子，如果创建文件时给的权限是0555，也就是所有用户都没有写的权限。但是程序后面还是可以对文件进行写操作。
=======================================================
    当mode参数是由八进制数字给出的时候，如 0777 .要纠正一个错误，就是之前我认为 权限数字前面的 0 代表的是八进制的含义，其实并不是这样的，前面的 0 代表了权限修饰位，也就是set-user-id位、set-group-id位和sticky这三位的权限。
=======================================================
    creat函数相当于open(pathname,  O_WRONLY | O_CREAT | O_TRUNC, mode)，由于open函数完全可以替代creat函数，所以现在基本上不用creat函数了。
 
 read（由已打开的文件读取数据）
相关函数

readdir，write，fcntl，close，lseek，readlink，fread
表头文件

#include<unistd.h>

定义函数

ssize_t read(int fd,void * buf ,size_t count);

函数说明

read()会把参数fd 所指的文件传送count个字节到buf指针所指的内存中。若参数count为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动。
 附加说明

如果顺利read()会返回实际读到的字节数，最好能将返回值与参数count作比较，若返回的字节数比要求读取的字节数少，则有可能读到了文件尾、从管道(pipe)或终端机读取，或者是read()被信号中断了读取动作。当有错误发生时则返回-1，错误代码存入errno中，而文件读写位置则无法预期。
错误代码

EINTR 此调用被信号所中断。

EAGAIN 当使用不可阻断I/O 时（O_NONBLOCK），若无数据可读取则返回此值。

EBADF 参数fd 非有效的文件描述词，或该文件已关闭。
范例

参考open（）。
write（将数据写入已打开的文件内）
相关函数

open，read，fcntl，close，lseek，sync，fsync，fwrite
表头文件

#include<unistd.h>

定义函数

ssize_t write (int fd,const void * buf,size_t count);

函数说明

write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。
返回值

如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。
错误代码

EINTR 此调用被信号所中断。
EAGAIN 当使用不可阻断I/O 时（O_NONBLOCK），若无数据可读取则返回此值。
EADF 参数fd非有效的文件描述词，或该文件已关闭。
范例

请参考open（）。
拷贝文件实例：

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#define BUFFER_SIZE 1024

int main(int argc, char **argv) 
{
    int from_fd, to_fd;
    int bytes_read, bytes_write;
    char buffer[BUFFER_SIZE];
    char *ptr;
    
    if (argc != 3) 
    {
        fprintf(stderr, "Usage：%s fromfile tofile\n\a", argv[0]);
        exit(1);
    }
    /* 打开源文件 */
    if ((from_fd = open(argv[1], O_RDONLY)) == -1) 
    {
        fprintf(stderr, "Open %s Error：%s\n", argv[1], strerror(errno));
        exit(1);
    }
    /* 创建目的文件 */
    if ((to_fd = open(argv[2], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1) 
    {
        fprintf(stderr, "Open %s Error：%s\n", argv[2], strerror(errno));
        exit(1);
    }
    /* 以下代码是一个经典的拷贝文件的代码 */
    while (bytes_read = read(from_fd, buffer, BUFFER_SIZE)) 
    {
        /* 一个致命的错误发生了 */
        if ((bytes_read == -1) && (errno != EINTR)) break;
        else if(bytes_read > 0) 
        {
            ptr = buffer;
            while (bytes_write = write(to_fd, ptr, bytes_read)) 
            {
                /* 一个致命错误发生了 */
                if ((bytes_write == -1) && (errno != EINTR))break;
                    /* 写完了所有读的字节 */
                else if(bytes_write == bytes_read)break;
                    /* 只写了一部分,继续写 */
                else if(bytes_write > 0) 
                {
                    ptr += bytes_write;
                    bytes_read -= bytes_write;
                }
            }
            /* 写的时候发生的致命错误 */
            if (bytes_write == -1)break;
        }
    }
    close(from_fd);
    close(to_fd);
    exit(0);
}

